### <font size=3pt face="MV Boli" color="gray">By Ruicheng Zhang</font>

# 基础

## 数据库三大范式

-   第一范式：表的每个字段必须是不可分割的独立单元
-   第二范式：在第一范式的基础上，要求每张表只表达一个意思。表的每个字段都和表的主键有依赖
-   第三范式：在第二范式的基础上，要求每张表的主键之外的其他字段都只能和主键有直接决定依赖关系

![三大范式](img/%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F.png)


## 连接

- 内连接：inner join，把匹配的关联数据显示出来
- 左连接：左边的表全部显示出来，右边的表显示出符合条件的数据
- 右连接
- 笛卡尔连接

# 原理

## 事务的四大特性

ACID

-   原子性
-   一致性
-   隔离性
-   持久性


## InnoDB & MyISAM & Memory

-   **存储结构**：

    InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。

    MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。

-   **事务支持**：InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交

-   **外键**：InnoDB支持，而MyISAM不支持

-   **表锁差异**：InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁

-   **表的具体行数**：InnoDB不保存表的具体行数，执行select count(\*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快

-   **AUTO_INCREMENT**：

    MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。
    InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。

![存储引擎](img/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png)



## 事物隔离级别

低级别的隔离一般支持更高的并发处理

1.   **读取未提交**

     事务可以看到未提交事务的执行结果

2.   **读取已提交**

     大多数数据库系统的默认隔离级别

3.   **可重复读**

     MySQL的默认隔离级别

4.   **可串行化**

     强制事务排序，解决幻读问题，在每个读的数据上加锁



-   **脏读**

    当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。

-   **不可重复读**

    是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。

-   **幻读**

    当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。





## 索引的设计和使用

### Hash索引 & B+ Tree索引

### B树、B+树





# 进阶（Todo）

## MVCC机制

多版本并发控制




## 主从复制原理
